import sys
import os
import json
import logging
from PIL import Image
from io import BytesIO
from typing import Tuple
from state import Map, State, Tileset

# Configuration and logging setup
version = "0.1.0"

# TODO: give all this as command line arguments
configuration = {
    # This is the name of the assets generated by the sprite packer
    "output_file_name": "sunnyvale",
    # Maximum tile size, set to a sensible factor of 32
    "tileset_image_width": 1152,
    # Where spritepacker dumps the resulting sprite atlases
    "image_output_path": "data/images/",
}
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

state = State()


def load_tilesets(tileset_directory_path: str):
    """Load tilesets from the specified directory."""
    logger.info("Loading tilesets from: %s", tileset_directory_path)
    for subdir, _, files in os.walk(tileset_directory_path, followlinks=False):
        for path in files:
            try:
                if path not in state.tilesets:
                    tileset = Tileset(os.path.join(subdir, path))
                    state.tilesets[path] = tileset
            except Exception as e:
                logger.error("Error loading tileset %s: %s", path, e)


def load_maps(maps_directory_path: str):
    """Load maps from the specified directory."""
    logger.info("Loading maps from: %s", maps_directory_path)
    for subdir, _, files in os.walk(maps_directory_path, followlinks=False):
        for path in files:
            try:
                map = Map(os.path.join(subdir, path))
                map.load()
                state.maps[path] = map
            except Exception as e:
                logger.error("Error loading map %s: %s", path, e)


def load_tiles_into_remap(map: Map):
    for layer in map.json["layers"]:
        if "data" not in layer:
            continue
        for raw_tile_id in layer["data"]:
            if raw_tile_id > 0:
                state.add_global_id_to_state(map, raw_tile_id)


def main():
    print("Tiled Sprite Packer v", version, sep="")

    if len(sys.argv) < 3:
        print(
            "Usage: python tileset_packer.py <tileset_directory_path> <maps_directory_path> <remapped_tileset_directory_path> <remapped_maps_output_directory_path>"
        )
        sys.exit(1)  # Exit the script with an error code

    tileset_directory_path: str = sys.argv[1]
    maps_directory_path: str = sys.argv[2]
    remapped_tileset_output_directory_path: str = sys.argv[3]
    remapped_maps_output_directory_path: str = sys.argv[4]

    load_tilesets(tileset_directory_path)
    load_maps(maps_directory_path)

    # Load the tiles into the remap state
    for key in state.maps:
        map = state.maps[key]
        print(map.file_path)
        load_tiles_into_remap(map)

    # Generate the remap ids for these tiles in the state
    state.generate_remap_ids()

    image_size = (configuration["tileset_image_width"], 100000)

    # go through each of the tilesets, each tile, write the sprite to an image
    for tileset_size_key in state.unified_tilemap:
        largest_image_x = 0
        image = Image.new("RGBA", image_size, color=(0, 0, 0, 0))

        (width, height) = [int(s) for s in tileset_size_key.split("x")]
        dest_tileset_columns = configuration["tileset_image_width"] // width

        # Go through each tileset for this size and write the tiles to the image for this size:
        for tileset_source in state.unified_tilemap[tileset_size_key]:
            tile_count = 0
            image_y = 0

            print("Writing tileset to image: ", tileset_source)
            tileset = state.tilesets[tileset_source]
            tile_size = (tileset.json["tilewidth"], tileset.json["tileheight"])

            with Image.open(tileset.json["image"]) as ts_image:
                for local_tile_id in state.unified_tilemap[tileset_size_key][
                    tileset_source
                ]:
                    tile_count += 1

                    remapped_id = state.unified_tilemap[tileset_size_key][
                        tileset_source
                    ][local_tile_id]
                    tileset_positional_id = remapped_id
                    new_tileset_tile_position = (
                        (tileset_positional_id % dest_tileset_columns) * tile_size[0],
                        (tileset_positional_id // dest_tileset_columns) * tile_size[1],
                    )

                    largest_image_x = max(
                        largest_image_x,
                        (tileset_positional_id % dest_tileset_columns + 1)
                        * tile_size[0],
                    )

                    image_y = new_tileset_tile_position[1]

                    tile_box = get_tile_box(tileset, local_tile_id)
                    tile_image_region = ts_image.crop(tile_box)

                    # Paste src into dest
                    image.paste(tile_image_region, new_tileset_tile_position)

        # Crop to the final size
        cropped = image.crop((0, 0, largest_image_x, image_y + tile_size[1]))

        remapped_file_name = "{}-{}".format(
            configuration["output_file_name"], tileset_size_key
        )

        write_image(
            cropped,
            "{}{}.png".format(configuration["image_output_path"], remapped_file_name),
        )

        tileset_file_path = "{}/{}.json".format(
            remapped_tileset_output_directory_path, remapped_file_name
        )

        os.makedirs(remapped_tileset_output_directory_path, exist_ok=True)

        write_tileset(
            remapped_file_name,
            cropped,
            tileset_size_key,
            tile_count,
            (width, height),
            tileset_file_path,
            dest_tileset_columns,
        )

    os.makedirs(remapped_maps_output_directory_path, exist_ok=True)

    for map_key, map in state.maps.items():
        state.rebuild_map(map)

        remap_state = map.remap_state

        map.json["tilesets"] = remap_state.tilesets

        remapped_file_path = "{}/{}".format(
            remapped_maps_output_directory_path, map_key
        )

        with open(remapped_file_path, "w") as file:
            file.write(json.dumps(map.json, indent=4))


def write_image(image: Image, image_file_path: str):
    buffer = BytesIO()
    image.save(buffer, format="PNG")

    buffer.seek(0)

    with open(image_file_path, "wb") as file:
        file.write(buffer.read())


def write_tileset(
    image_file_name_sans_ext: str,
    image: Image,
    tileset_size_key: str,
    tile_count: int,
    tile_size: Tuple[int, int],
    tileset_file_path: str,
    tiles_per_column: int,
):
    width, height = image.size

    tileset_config = {
        "columns": tiles_per_column,
        "image": "{}{}.png".format(
            configuration["image_output_path"], image_file_name_sans_ext
        ),
        "imageheight": height,
        "imagewidth": width,
        "margin": 0,
        "name": image_file_name_sans_ext,
        "spacing": 0,
        "tilecount": tile_count,
        "tiledversion": "1.10.1",
        "tileheight": tile_size[1],
        "tilewidth": tile_size[0],
        "type": "tileset",
        "version": "1.10",
    }

    remapped_tileset_tiles = []

    remap_state_for_size = state.unified_tilemap[tileset_size_key]

    tilesets_for_size = (
        tileset
        for _, tileset in state.tilesets.items()
        if tileset.tileset_key == tileset_size_key
    )

    for tileset in tilesets_for_size:
        if tileset_size_key not in state.unified_tilemap:
            exit(
                "Tileset Size of `{}` not registered in the unified tilemap! Exiting...".format(
                    tileset_size_key
                )
            )

        if tileset.source not in remap_state_for_size:
            logger.warning(
                "Tileset `{}` not in the remap state..!".format(tileset.source)
            )
            continue

        tileset_remap_data = remap_state_for_size[tileset.source]

        tiles = tileset.json["tiles"] if "tiles" in tileset.json else []

        for tile in tiles:
            # Not sure about this one, might be ignoring tiles I need?

            if tile["id"] not in tileset_remap_data:
                logger.warning(
                    "Tile `{}` has not been remapped for source `{}`..!".format(
                        tile["id"], tileset.source
                    )
                )
                continue

            tile["id"] = tileset_remap_data[tile["id"]]

            if "animation" in tile:
                for frame in tile["animation"]:
                    if frame["tileid"] not in tileset_remap_data:
                        print(
                            "Frame `{}` has not been remapped for source `{}`..!".format(
                                frame["tileid"], tileset.source
                            )
                        )
                        continue

                    frame["tileid"] = tileset_remap_data[frame["tileid"]]

            remapped_tileset_tiles.append(tile)

    remapped_tileset_tiles.sort(key=lambda x: x["id"])
    tileset_config["tiles"] = remapped_tileset_tiles

    with open(tileset_file_path, "w") as outfile:
        outfile.write(json.dumps(tileset_config, indent=4))


def get_tile_box(tileset: Tileset, local_tile_id: int):
    image_size = (tileset.json["imagewidth"], tileset.json["imageheight"])
    tile_size = (tileset.json["tilewidth"], tileset.json["tileheight"])
    tiles_per_width = int(image_size[0] / tile_size[0])

    index = (int(local_tile_id % tiles_per_width), int(local_tile_id / tiles_per_width))
    pixel_index = (index[0] * tile_size[0], index[1] * tile_size[1])

    return (
        pixel_index[0],
        pixel_index[1],
        pixel_index[0] + tile_size[0],
        pixel_index[1] + tile_size[1],
    )


if __name__ == "__main__":
    main()
